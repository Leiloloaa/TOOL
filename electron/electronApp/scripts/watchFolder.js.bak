const fs = require("fs");
const path = require("path");
const { processImages } = require("./handleImage.js");

class FolderWatcher {
  constructor() {
    this.watcher = null;
    this.isWatching = false;
    this.watchPath = null;
    this.namingMode = null;
    this.processedFiles = new Set(); // é˜²æ­¢é‡å¤å¤„ç†
    this.processingQueue = []; // å¤„ç†é˜Ÿåˆ—
    this.isProcessing = false;
  }

  /**
   * å¼€å§‹ç›‘å¬æ–‡ä»¶å¤¹
   * @param {string} folderPath - è¦ç›‘å¬çš„æ–‡ä»¶å¤¹è·¯å¾„
   * @param {string} namingMode - å‘½åæ¨¡å¼
   * @param {Function} onFileChange - æ–‡ä»¶å˜åŒ–å›è°ƒ
   * @param {Function} onImageProcessStart - å›¾ç‰‡å¤„ç†å¼€å§‹å›è°ƒ
   * @param {Function} onImageProcessComplete - å›¾ç‰‡å¤„ç†å®Œæˆå›è°ƒ
   * @param {Function} onImageProcessError - å›¾ç‰‡å¤„ç†é”™è¯¯å›è°ƒ
   * @param {Function} onWatchError - ç›‘å¬é”™è¯¯å›è°ƒ
   * @param {Function} onWatchStop - ç›‘å¬åœæ­¢å›è°ƒ
   */
  startWatching(folderPath, namingMode, callbacks = {}) {
    if (this.isWatching) {
      throw new Error("Already watching a folder");
    }

    this.watchPath = folderPath;
    this.namingMode = namingMode;
    this.processedFiles.clear();
    this.processingQueue = [];
    this.isProcessing = false;

    // éªŒè¯æ–‡ä»¶å¤¹æ˜¯å¦å­˜åœ¨
    if (!fs.existsSync(folderPath)) {
      throw new Error(`Folder ${folderPath} does not exist`);
    }

    // åˆ›å»ºç›‘å¬å™¨
    this.watcher = fs.watch(
      folderPath,
      {
        recursive: true,
        persistent: true,
      },
      (eventType, fileName) => {
        if (!fileName) return;

        // å¿½ç•¥éšè—æ–‡ä»¶
        if (fileName.startsWith(".")) return;

        const filePath = path.join(folderPath, fileName);

        // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼ˆé¿å…åˆ é™¤äº‹ä»¶ï¼‰
        if (eventType === "rename" && !fs.existsSync(filePath)) {
          return; // æ–‡ä»¶è¢«åˆ é™¤ï¼Œå¿½ç•¥
        }

        if (eventType === "change" || eventType === "rename") {
          this.handleFileChange(filePath, eventType, callbacks);
        }
      }
    );

    // ç›‘å¬é”™è¯¯
    this.watcher.on("error", (error) => {
      console.error("Watch error:", error);
      if (callbacks.onWatchError) {
        callbacks.onWatchError(error);
      }
    });

    this.isWatching = true;
    console.log(`Started watching folder: ${folderPath}`);
  }

  /**
   * å¤„ç†æ–‡ä»¶å˜åŒ–
   * @param {string} filePath - æ–‡ä»¶è·¯å¾„
   * @param {string} eventType - äº‹ä»¶ç±»å‹
   * @param {Object} callbacks - å›è°ƒå‡½æ•°
   */
  async handleFileChange(filePath, eventType, callbacks) {
    try {
      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
      if (!fs.existsSync(filePath)) {
        return;
      }

      const fileName = path.basename(filePath);
      const fileExt = path.extname(filePath).toLowerCase();

      // æ£€æŸ¥æ˜¯å¦ä¸ºå›¾ç‰‡æ–‡ä»¶
      const imageExtensions = [
        ".png",
        ".jpg",
        ".jpeg",
        ".gif",
        ".bmp",
        ".webp",
      ];
      if (!imageExtensions.includes(fileExt)) {
        return; // ä¸æ˜¯å›¾ç‰‡æ–‡ä»¶ï¼Œå¿½ç•¥
      }

      // æ£€æŸ¥æ˜¯å¦å·²ç»å¤„ç†è¿‡
      if (this.processedFiles.has(filePath)) {
        return;
      }

      // é€šçŸ¥æ–‡ä»¶å˜åŒ–
      if (callbacks.onFileChange) {
        callbacks.onFileChange({
          fileName: fileName,
          filePath: filePath,
          eventType: eventType,
        });
      }

      // æ·»åŠ åˆ°å¤„ç†é˜Ÿåˆ—
      this.processingQueue.push({
        filePath: filePath,
        fileName: fileName,
        callbacks: callbacks,
      });

      // å¼€å§‹å¤„ç†é˜Ÿåˆ—
      if (!this.isProcessing) {
        this.processQueue();
      }
    } catch (error) {
      console.error("Error handling file change:", error);
      if (callbacks.onWatchError) {
        callbacks.onWatchError(error);
      }
    }
  }

  /**
   * å¤„ç†é˜Ÿåˆ—ä¸­çš„æ–‡ä»¶
   */
  async processQueue() {
    if (this.isProcessing || this.processingQueue.length === 0) {
      return;
    }

    this.isProcessing = true;

    while (this.processingQueue.length > 0) {
      const item = this.processingQueue.shift();
      await this.processImageFile(item);
    }

    this.isProcessing = false;
  }

  /**
   * å¤„ç†å•ä¸ªå›¾ç‰‡æ–‡ä»¶
   * @param {Object} item - é˜Ÿåˆ—é¡¹
   */
  async processImageFile(item) {
    const { filePath, fileName, callbacks } = item;

    try {
      // è®°å½•å¼€å§‹æ—¶é—´
      this.startTime = Date.now();

      // æ ‡è®°ä¸ºå·²å¤„ç†
      this.processedFiles.add(filePath);

      // é€šçŸ¥å¤„ç†å¼€å§‹
      if (callbacks.onImageProcessStart) {
        callbacks.onImageProcessStart({
          fileName: fileName,
          filePath: filePath,
        });
      }

      // ç­‰å¾…æ–‡ä»¶å†™å…¥å®Œæˆ
      await this.waitForFileStable(filePath);

      // å†æ¬¡æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
      if (!fs.existsSync(filePath)) {
        throw new Error(
          `File ${fileName} no longer exists after waiting for stability`
        );
      }

      // åˆ›å»ºä¸´æ—¶ç›®å½•è¿›è¡Œå›¾ç‰‡å¤„ç†
      const tempDir = path.join(path.dirname(filePath), `temp_${Date.now()}`);
      fs.mkdirSync(tempDir, { recursive: true });

      // å¤åˆ¶æ–‡ä»¶åˆ°ä¸´æ—¶ç›®å½•
      const tempFilePath = path.join(tempDir, fileName);
      fs.copyFileSync(filePath, tempFilePath);

      // éªŒè¯å¤åˆ¶æ˜¯å¦æˆåŠŸ
      if (!fs.existsSync(tempFilePath)) {
        throw new Error(
          `Failed to copy file ${fileName} to temporary directory`
        );
      }

      // è®°å½•åŸå§‹æ–‡ä»¶å¤§å°
      const originalStats = fs.statSync(filePath);
      const originalSize = originalStats.size;
      console.log(
        `ğŸ“ Processing: ${fileName} (Original: ${this.formatSize(originalSize)})`
      );

      // å¤„ç†å›¾ç‰‡
      await processImages(tempDir, this.namingMode);

      // å°†å¤„ç†åçš„æ–‡ä»¶å¤åˆ¶å›åŸä½ç½®
      const processedFiles = fs.readdirSync(tempDir);
      let processedSize = 0;
      let processedFileName = fileName;

      for (const processedFile of processedFiles) {
        const processedFilePath = path.join(tempDir, processedFile);
        const targetFilePath = path.join(path.dirname(filePath), processedFile);

        // è®°å½•å¤„ç†åçš„æ–‡ä»¶ä¿¡æ¯
        const processedStats = fs.statSync(processedFilePath);
        processedSize = processedStats.size;
        processedFileName = processedFile;

        // å¦‚æœç›®æ ‡æ–‡ä»¶å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤
        if (fs.existsSync(targetFilePath)) {
          fs.unlinkSync(targetFilePath);
        }

        // ä½¿ç”¨ copyFileSync è€Œä¸æ˜¯ renameSyncï¼Œé¿å…è·¨æ–‡ä»¶ç³»ç»Ÿçš„é—®é¢˜
        fs.copyFileSync(processedFilePath, targetFilePath);
        fs.unlinkSync(processedFilePath); // åˆ é™¤ä¸´æ—¶æ–‡ä»¶
      }

      // æ‰“å°å‹ç¼©å¯¹æ¯”ä¿¡æ¯
      if (processedSize > 0) {
        const savedSize = originalSize - processedSize;
        const compressionRate = ((savedSize / originalSize) * 100).toFixed(2);
        console.log(
          `âœ… Optimized: ${processedFileName} (${compressionRate}% smaller) (${this.formatTime(Date.now() - this.startTime)})`
        );
        console.log(`  Original size: ${this.formatSize(originalSize)}`);
        console.log(`  Optimized size: ${this.formatSize(processedSize)}`);
        console.log(`  Saved: ${this.formatSize(savedSize)}`);
      }

      // åˆ é™¤ä¸´æ—¶ç›®å½•
      try {
        fs.rmdirSync(tempDir);
      } catch (rmError) {
        // å¦‚æœç›®å½•ä¸ä¸ºç©ºï¼Œé€’å½’åˆ é™¤
        if (rmError.code === "ENOTEMPTY") {
          fs.rmSync(tempDir, { recursive: true, force: true });
        }
      }

      // é€šçŸ¥å¤„ç†å®Œæˆ
      if (callbacks.onImageProcessComplete) {
        callbacks.onImageProcessComplete({
          fileName: fileName,
          filePath: filePath,
        });
      }
    } catch (error) {
      console.error(`Error processing image ${fileName}:`, error);

      // æ¸…ç†ä¸´æ—¶ç›®å½•ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
      try {
        const tempDir = path.join(path.dirname(filePath), `temp_${Date.now()}`);
        if (fs.existsSync(tempDir)) {
          fs.rmSync(tempDir, { recursive: true, force: true });
        }
      } catch (cleanupError) {
        console.error("Error cleaning up temporary directory:", cleanupError);
      }

      // é€šçŸ¥å¤„ç†é”™è¯¯
      if (callbacks.onImageProcessError) {
        callbacks.onImageProcessError({
          fileName: fileName,
          filePath: filePath,
          error: error.message,
        });
      }
    }
  }

  /**
   * ç­‰å¾…æ–‡ä»¶å†™å…¥ç¨³å®š
   * @param {string} filePath - æ–‡ä»¶è·¯å¾„
   */
  async waitForFileStable(filePath) {
    return new Promise((resolve) => {
      let lastSize = -1;
      let stableCount = 0;
      const maxStableCount = 3; // è¿ç»­3æ¬¡å¤§å°ä¸å˜è®¤ä¸ºç¨³å®š
      const maxWaitTime = 15000; // æœ€å¤§ç­‰å¾…æ—¶é—´15ç§’
      const startTime = Date.now();

      const checkFile = () => {
        try {
          // æ£€æŸ¥æ˜¯å¦è¶…æ—¶
          if (Date.now() - startTime > maxWaitTime) {
            console.warn(`File ${filePath} stability check timeout`);
            resolve();
            return;
          }

          if (!fs.existsSync(filePath)) {
            console.log(`File ${filePath} does not exist, waiting...`);
            setTimeout(checkFile, 1000); // å¢åŠ ç­‰å¾…æ—¶é—´
            return;
          }

          const stats = fs.statSync(filePath);
          const currentSize = stats.size;

          // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å¯è¯»
          try {
            fs.accessSync(filePath, fs.constants.R_OK);
          } catch (accessError) {
            console.log(`File ${filePath} not readable yet, waiting...`);
            setTimeout(checkFile, 1000);
            return;
          }

          if (currentSize === lastSize && currentSize > 0) {
            stableCount++;
            if (stableCount >= maxStableCount) {
              console.log(
                `File ${filePath} is stable (size: ${currentSize} bytes)`
              );
              resolve();
              return;
            }
          } else {
            stableCount = 0;
            lastSize = currentSize;
          }

          setTimeout(checkFile, 1000); // å¢åŠ æ£€æŸ¥é—´éš”
        } catch (error) {
          console.log(`Error checking file ${filePath}:`, error.message);
          setTimeout(checkFile, 1000);
        }
      };

      checkFile();
    });
  }

  /**
   * åœæ­¢ç›‘å¬
   */
  stopWatching() {
    if (this.watcher) {
      this.watcher.close();
      this.watcher = null;
    }

    this.isWatching = false;
    this.watchPath = null;
    this.namingMode = null;
    this.processedFiles.clear();
    this.processingQueue = [];
    this.isProcessing = false;

    console.log("Stopped watching folder");
  }

  /**
   * è·å–ç›‘å¬çŠ¶æ€
   */
  getStatus() {
    return {
      isWatching: this.isWatching,
      watchPath: this.watchPath,
      namingMode: this.namingMode,
      processedFilesCount: this.processedFiles.size,
      queueLength: this.processingQueue.length,
      isProcessing: this.isProcessing,
    };
  }

  /**
   * æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
   * @param {number} bytes - å­—èŠ‚æ•°
   * @returns {string} æ ¼å¼åŒ–åçš„å¤§å°
   */
  formatSize(bytes) {
    if (bytes === 0) return "0 B";
    const k = 1024;
    const sizes = ["B", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }

  /**
   * æ ¼å¼åŒ–æ—¶é—´
   * @param {number} milliseconds - æ¯«ç§’æ•°
   * @returns {string} æ ¼å¼åŒ–åçš„æ—¶é—´
   */
  formatTime(milliseconds) {
    if (milliseconds < 1000) return `${milliseconds}ms`;
    const seconds = Math.floor(milliseconds / 1000);
    return `${seconds}s`;
  }
}

// åˆ›å»ºå…¨å±€å®ä¾‹
const folderWatcher = new FolderWatcher();

module.exports = {
  FolderWatcher,
  folderWatcher,
};
